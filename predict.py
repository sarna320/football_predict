# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18WAALVpwgYWi7pf8cefb-B2Fb_8NAzFi
"""

import pandas as pd
from sklearn.model_selection import TimeSeriesSplit
from sklearn.feature_selection import SequentialFeatureSelector
from sklearn.linear_model import RidgeClassifier
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import accuracy_score

matches = pd.read_csv("matches.csv", index_col=0)

matches

class MissingDict(dict):
    __missing__ = lambda self, key: key

map_values = {
    "Liverpool": "Liverpool",
    "CrystalPalace": "Crystal Palace",
    "Arsenal": "Arsenal",
    "TottenhamHotspur": "Tottenham",
    "ManchesterUnited": "Manchester Utd",
    "NewcastleUnited": "Newcastle Utd",
    "Chelsea": "Chelsea",
    "WolverhamptonWanderers": "Wolves",
    "Everton": "Everton",
    "ManchesterCity": "Manchester City",
    "WestHamUnited": "West Ham",
    "BrightonandHoveAlbion": "Brighton",
    "LeicesterCity": "Leicester City",
    "Southampton": "Southampton",
    "AstonVilla": "Aston Villa",
    "Burnley": "Burnley",
    "Fulham": "Fulham",
    "Bournemouth": "Bournemouth",
    "Watford": "Watford",
    "LeedsUnited": "Leeds United",
    "SheffieldUnited": "Sheffield Utd",
    "Brentford": "Brentford",
    "NorwichCity": "Norwich City",
    "NottinghamForest": "Nott'ham Forest",
    "WestBromwichAlbion": "West Brom",
    "CardiffCity": "Cardiff City",
    "HuddersfieldTown": "Huddersfield",
    "LutonTown": "Luton Town",
}

mapping = MissingDict(**map_values)

matches["date"] = pd.to_datetime(matches["date"])

matches["team"] = matches["team"].map(mapping)

matches["venue_code"] = matches["venue"].astype("category").cat.codes

matches["opponent_code"] = matches["opponent"].astype("category").cat.codes

matches["opponent_code"].value_counts()

matches["hour"] = matches["time"].str.replace(":.+", "", regex=True).astype("int")

matches["day_code"] = matches["day"].astype("category").cat.codes

matches["formation_code"] = matches["formation"].astype("category").cat.codes

matches["won"] = matches["result"] == "W"

matches

matches = matches.sort_values("date")
matches = matches.reset_index(drop=True)

matches

def add_target(team):
    team["target"] = team["won"].shift(-1)
    return team

matches = matches.groupby("team", group_keys=False).apply(add_target)

matches

matches["target"][pd.isnull(matches["target"])] = 2
matches["target"] = matches["target"].astype(int, errors="ignore")

matches

nulls = pd.isnull(matches)
nulls = nulls.sum()
nulls = nulls[nulls > 0]
valid_columns = matches.columns[~matches.columns.isin(nulls.index)]
matches = matches[valid_columns].copy()

matches

rr=RidgeClassifier(alpha=1)
split=TimeSeriesSplit(n_splits=3)
sfs=SequentialFeatureSelector(rr,n_features_to_select=30,direction="forward",cv=split)

removed_columns=["won","date","target","team"]
removed_columns = list(matches.columns[matches.dtypes == "object"])+removed_columns+list(matches.columns[matches.dtypes == "datetime64[ns]"])
selected_columns = matches.columns[~matches.columns.isin(removed_columns)]

matches[selected_columns].dtypes

scaler=MinMaxScaler()
matches[selected_columns]=scaler.fit_transform(matches[selected_columns])

matches

sfs.fit(matches[selected_columns],matches["target"])

predictors=list(selected_columns[sfs.get_support()])

predictors

def backtest(data,model,predictors,start=2,step=1):
    all_preditcions=[]
    seasons=sorted(data["season"].unique())

    for i in range(start,len(seasons),step):
        season=seasons[i]
        train=data[data["season"]<season]
        test=data[data["season"]==season]

        model.fit(train[predictors],train["target"])

        preds=model.predict(test[predictors])

        preds=pd.Series(preds,index=test.index)

        combined=pd.concat([test["target"],preds],axis=1)
        combined.columns=["actual","prediction"]

        all_preditcions.append(combined)
    return pd.concat(all_preditcions)

predictions=backtest(matches,rr,predictors)

predictions

accuracy_score(predictions["actual"],predictions["prediction"])

matches_rolling=matches[list(selected_columns)+["won","team","season"]]

def finnd_team_avarages(team):
  cols_to_roll = team[list(selected_columns) + ["won"]]
  roll = cols_to_roll.rolling(10).mean()
  roll['team'] = team['team']
  roll['season'] = team['season']
  return roll

matches_rolling=matches_rolling.groupby(["team","season"],group_keys=False).apply(finnd_team_avarages)

rolling_cols=[f"{col}_10" for col in matches_rolling.columns]
matches_rolling.columns=rolling_cols
matches=pd.concat([matches,matches_rolling],axis=1)

matches

matches=matches.dropna()

def shift_col(team, col_name):
    next_col = team[col_name].shift(-1)
    return next_col

def add_col(df, col_name):
    return df.groupby("team", group_keys=False).apply(lambda x: shift_col(x, col_name))

matches["venue_code_next"] = add_col(matches, "venue_code")
matches["opponente_next"] = add_col(matches, "opponent")
matches["date_next"] = add_col(matches, "date")
matches=matches.copy()

matches

full = matches.merge(matches[rolling_cols + ["opponente_next", "date_next", "team"]], left_on=["team", "date_next"], right_on=["opponente_next", "date_next"])

full[["team_x", "opponente_next_x", "team_y", "opponente_next_y", "date_next"]]

removed_columns=["won","date","target"]
removed_columns = list(full.columns[full.dtypes == "object"])+removed_columns+list(full.columns[full.dtypes == "datetime64[ns]"])
selected_columns = full.columns[~full.columns.isin(removed_columns)]

sfs.fit(full[selected_columns], full["target"])

predictors = list(selected_columns[sfs.get_support()])
predictions = backtest(full, rr, predictors)
predictors

accuracy_score(predictions["actual"], predictions["prediction"])

sfs=SequentialFeatureSelector(rr,n_features_to_select=100,direction="forward",cv=split)
sfs.fit(full[selected_columns], full["target"])
predictors = list(selected_columns[sfs.get_support()])
predictions = backtest(full, rr, predictors)
print(predictors)
print(accuracy_score(predictions["actual"], predictions["prediction"]))

predictors = list(selected_columns[sfs.get_support()])

print(accuracy_score(predictions["actual"], predictions["prediction"]))